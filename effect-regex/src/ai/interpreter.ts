/**
 * Safe interpreter for LLM-generated RegexBuilder code
 *
 * This module provides a secure way to execute code generated by LLMs without
 * using eval(). It parses the code into an AST, validates that it only contains
 * allowed RegexBuilder API calls, and executes by calling actual RegexBuilder
 * methods instead of evaluating arbitrary JavaScript.
 *
 * Security guarantees:
 * - No eval() or Function() constructor usage
 * - Only whitelisted RegexBuilder methods allowed
 * - No access to global scope or require/import
 * - No arbitrary code execution
 * - Input size limits enforced
 */

import type { RegexBuilder } from "../core/builder.js";
import { RegexBuilder as RB } from "../core/builder.js";

/**
 * Maximum allowed code length (characters)
 */
const MAX_CODE_LENGTH = 10_000;

/**
 * Maximum allowed method chain depth
 */
const MAX_CHAIN_DEPTH = 100;

/**
 * Error thrown when code interpretation fails
 */
export class CodeInterpreterError extends Error {
  readonly _tag = "CodeInterpreterError";

  constructor(
    message: string,
    readonly code: string,
    readonly cause?: unknown
  ) {
    super(message);
    this.name = "CodeInterpreterError";
  }
}

/**
 * Allowed RegexBuilder static methods
 */
const ALLOWED_STATIC_METHODS = new Set([
  "lit",
  "raw",
  "digit",
  "word",
  "whitespace",
  "any",
  "charClass",
  "alt",
]);

/**
 * Allowed RegexBuilder instance methods
 */
const ALLOWED_INSTANCE_METHODS = new Set([
  "then",
  "or",
  "zeroOrMore",
  "oneOrMore",
  "optional",
  "exactly",
  "atLeast",
  "between",
  "capture",
  "group",
  "startOfLine",
  "endOfLine",
  "wordBoundary",
]);

/**
 * Token types for simple lexer
 */
type TokenType =
  | "IDENTIFIER"
  | "DOT"
  | "LPAREN"
  | "RPAREN"
  | "STRING"
  | "NUMBER"
  | "TRUE"
  | "FALSE"
  | "COMMA"
  | "EOF";

interface Token {
  type: TokenType;
  value: string;
  position: number;
}

/**
 * Simple lexer for RegexBuilder code
 */
class Lexer {
  private pos = 0;
  private readonly code: string;

  constructor(code: string) {
    this.code = code.trim();
  }

  private peek(): string {
    return this.code[this.pos] || "";
  }

  private advance(): string {
    return this.code[this.pos++] || "";
  }

  private skipWhitespace(): void {
    while (this.pos < this.code.length && /\s/.test(this.peek())) {
      this.pos++;
    }
  }

  private readString(): string {
    const quote = this.advance(); // Consume opening quote
    let value = "";
    let escaped = false;

    while (this.pos < this.code.length) {
      const char = this.advance();

      if (escaped) {
        value += char;
        escaped = false;
      } else if (char === "\\") {
        escaped = true;
        value += char;
      } else if (char === quote) {
        return value;
      } else {
        value += char;
      }
    }

    throw new CodeInterpreterError(
      `Unterminated string literal at position ${this.pos}`,
      this.code
    );
  }

  private readNumber(): string {
    let value = "";
    while (this.pos < this.code.length && /[0-9]/.test(this.peek())) {
      value += this.advance();
    }
    return value;
  }

  private readIdentifier(): string {
    let value = "";
    while (
      this.pos < this.code.length &&
      /[a-zA-Z0-9_]/.test(this.peek())
    ) {
      value += this.advance();
    }
    return value;
  }

  nextToken(): Token {
    this.skipWhitespace();

    if (this.pos >= this.code.length) {
      return { type: "EOF", value: "", position: this.pos };
    }

    const char = this.peek();
    const position = this.pos;

    // String literals
    if (char === '"' || char === "'" || char === "`") {
      return {
        type: "STRING",
        value: this.readString(),
        position,
      };
    }

    // Numbers
    if (/[0-9]/.test(char)) {
      return {
        type: "NUMBER",
        value: this.readNumber(),
        position,
      };
    }

    // Identifiers and keywords
    if (/[a-zA-Z_]/.test(char)) {
      const value = this.readIdentifier();

      if (value === "true") {
        return { type: "TRUE", value, position };
      }
      if (value === "false") {
        return { type: "FALSE", value, position };
      }

      return { type: "IDENTIFIER", value, position };
    }

    // Single-character tokens
    this.advance();

    switch (char) {
      case ".":
        return { type: "DOT", value: char, position };
      case "(":
        return { type: "LPAREN", value: char, position };
      case ")":
        return { type: "RPAREN", value: char, position };
      case ",":
        return { type: "COMMA", value: char, position };
      default:
        throw new CodeInterpreterError(
          `Unexpected character '${char}' at position ${position}`,
          this.code
        );
    }
  }

  tokenize(): Token[] {
    const tokens: Token[] = [];

    while (true) {
      const token = this.nextToken();
      tokens.push(token);

      if (token.type === "EOF") {
        break;
      }
    }

    return tokens;
  }
}

/**
 * AST node for method call
 */
interface MethodCallNode {
  type: "static" | "instance";
  methodName: string;
  args: ArgumentNode[];
}

/**
 * AST node for argument
 */
type ArgumentNode =
  | { type: "string"; value: string }
  | { type: "number"; value: number }
  | { type: "boolean"; value: boolean }
  | { type: "builder"; value: MethodCallNode[] }; // Nested RegexBuilder calls

/**
 * Parser for RegexBuilder method chains
 */
class Parser {
  private pos = 0;
  private readonly tokens: Token[];
  private readonly code: string;

  constructor(tokens: Token[], code: string) {
    this.tokens = tokens;
    this.code = code;
  }

  private peek(): Token {
    return this.tokens[this.pos] || { type: "EOF", value: "", position: -1 };
  }

  private advance(): Token {
    return this.tokens[this.pos++] || { type: "EOF", value: "", position: -1 };
  }

  private expect(type: TokenType): Token {
    const token = this.peek();

    if (token.type !== type) {
      throw new CodeInterpreterError(
        `Expected ${type} but got ${token.type} at position ${token.position}`,
        this.code
      );
    }

    return this.advance();
  }

  private parseArgument(): ArgumentNode {
    const token = this.peek();

    switch (token.type) {
      case "STRING":
        this.advance();
        return { type: "string", value: token.value };

      case "NUMBER":
        this.advance();
        return { type: "number", value: Number.parseInt(token.value, 10) };

      case "TRUE":
        this.advance();
        return { type: "boolean", value: true };

      case "FALSE":
        this.advance();
        return { type: "boolean", value: false };

      case "IDENTIFIER":
        // This could be a nested RegexBuilder call
        if (token.value === "RegexBuilder") {
          return this.parseNestedBuilder();
        }
        throw new CodeInterpreterError(
          `Unexpected identifier '${token.value}' at position ${token.position}`,
          this.code
        );

      default:
        throw new CodeInterpreterError(
          `Unexpected argument type ${token.type} at position ${token.position}`,
          this.code
        );
    }
  }

  private parseNestedBuilder(): ArgumentNode {
    // Parse nested RegexBuilder call (e.g., RegexBuilder.lit("test"))
    this.expect("IDENTIFIER"); // Consume "RegexBuilder"
    this.expect("DOT");

    const calls: MethodCallNode[] = [];
    calls.push(this.parseStaticCall());

    // Parse method chain
    while (this.peek().type === "DOT") {
      calls.push(this.parseInstanceCall());
    }

    return { type: "builder", value: calls };
  }

  private parseArguments(): ArgumentNode[] {
    this.expect("LPAREN");

    const args: ArgumentNode[] = [];

    if (this.peek().type !== "RPAREN") {
      args.push(this.parseArgument());

      while (this.peek().type === "COMMA") {
        this.advance(); // Consume comma
        args.push(this.parseArgument());
      }
    }

    this.expect("RPAREN");

    return args;
  }

  parseStaticCall(): MethodCallNode {
    const methodToken = this.expect("IDENTIFIER");

    if (!ALLOWED_STATIC_METHODS.has(methodToken.value)) {
      throw new CodeInterpreterError(
        `Disallowed static method: ${methodToken.value}`,
        this.code
      );
    }

    const args = this.parseArguments();

    return {
      type: "static",
      methodName: methodToken.value,
      args,
    };
  }

  parseInstanceCall(): MethodCallNode {
    this.expect("DOT");

    const methodToken = this.expect("IDENTIFIER");

    if (!ALLOWED_INSTANCE_METHODS.has(methodToken.value)) {
      throw new CodeInterpreterError(
        `Disallowed instance method: ${methodToken.value}`,
        this.code
      );
    }

    const args = this.parseArguments();

    return {
      type: "instance",
      methodName: methodToken.value,
      args,
    };
  }

  parse(): MethodCallNode[] {
    const calls: MethodCallNode[] = [];

    // Expect "RegexBuilder"
    const classToken = this.expect("IDENTIFIER");
    if (classToken.value !== "RegexBuilder") {
      throw new CodeInterpreterError(
        "Code must start with 'RegexBuilder'",
        ""
      );
    }

    // Parse initial static method call
    this.expect("DOT");
    calls.push(this.parseStaticCall());

    // Parse method chain
    while (this.peek().type === "DOT") {
      calls.push(this.parseInstanceCall());

      if (calls.length > MAX_CHAIN_DEPTH) {
        throw new CodeInterpreterError(
          `Method chain exceeds maximum depth of ${MAX_CHAIN_DEPTH}`,
          ""
        );
      }
    }

    // Should be at EOF
    if (this.peek().type !== "EOF") {
      const token = this.peek();
      throw new CodeInterpreterError(
        `Unexpected token ${token.type} at position ${token.position}`,
        ""
      );
    }

    return calls;
  }
}

/**
 * Execute a method call node by calling actual RegexBuilder methods
 */
function executeMethodCall(
  builder: RegexBuilder | typeof RB,
  call: MethodCallNode
): RegexBuilder {
  const { methodName, args } = call;

  // Convert ArgumentNodes to actual values
  const actualArgs = args.map((arg) => {
    switch (arg.type) {
      case "string":
        return arg.value;
      case "number":
        return arg.value;
      case "boolean":
        return arg.value;
      case "builder":
        // Execute nested builder
        return executeMethodChain(arg.value);
    }
  });

  // Call the method
  // @ts-expect-error - Dynamic method call, validated at parse time
  const result = builder[methodName](...actualArgs);

  if (!(result instanceof RB)) {
    throw new CodeInterpreterError(
      `Method ${methodName} did not return a RegexBuilder instance`,
      ""
    );
  }

  return result as RegexBuilder;
}

/**
 * Execute a chain of method calls
 */
function executeMethodChain(calls: MethodCallNode[]): RegexBuilder {
  if (calls.length === 0) {
    throw new CodeInterpreterError("No method calls found in chain", "");
  }

  let result: RegexBuilder | typeof RB = RB;

  for (const call of calls) {
    result = executeMethodCall(result, call);
  }

  if (!(result instanceof RB)) {
    throw new CodeInterpreterError(
      "Final result is not a RegexBuilder instance",
      ""
    );
  }

  return result;
}

/**
 * Safely interpret and execute RegexBuilder code
 *
 * @param code - LLM-generated RegexBuilder code
 * @returns RegexBuilder instance
 * @throws CodeInterpreterError if code is invalid or unsafe
 *
 * @example
 * ```typescript
 * const code = 'RegexBuilder.lit("test").then("foo").oneOrMore()';
 * const pattern = interpretRegexBuilderCode(code);
 * ```
 */
export function interpretRegexBuilderCode(code: string): RegexBuilder {
  // Validate input size
  if (code.length > MAX_CODE_LENGTH) {
    throw new CodeInterpreterError(
      `Code exceeds maximum length of ${MAX_CODE_LENGTH} characters`,
      code
    );
  }

  // Basic security checks
  if (code.includes("eval") || code.includes("Function")) {
    throw new CodeInterpreterError(
      "Code contains disallowed keywords (eval, Function)",
      code
    );
  }

  if (code.includes("require") || code.includes("import")) {
    throw new CodeInterpreterError(
      "Code contains disallowed keywords (require, import)",
      code
    );
  }

  if (code.includes("process") || code.includes("global")) {
    throw new CodeInterpreterError(
      "Code contains disallowed keywords (process, global)",
      code
    );
  }

  try {
    // Tokenize
    const lexer = new Lexer(code);
    const tokens = lexer.tokenize();

    // Parse
    const parser = new Parser(tokens, code);
    const calls = parser.parse();

    if (calls.length === 0) {
      throw new CodeInterpreterError("No method calls found in code", code);
    }

    // Execute method chain
    return executeMethodChain(calls);
  } catch (error) {
    if (error instanceof CodeInterpreterError) {
      throw error;
    }

    throw new CodeInterpreterError(
      `Failed to interpret code: ${(error as Error).message}`,
      code,
      error
    );
  }
}

/**
 * Validate RegexBuilder code without executing it
 *
 * @param code - Code to validate
 * @returns true if code is valid and safe
 */
export function validateRegexBuilderCode(code: string): boolean {
  try {
    interpretRegexBuilderCode(code);
    return true;
  } catch {
    return false;
  }
}
